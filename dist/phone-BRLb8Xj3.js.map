{"version":3,"file":"phone-BRLb8Xj3.js","names":["opts: PhoneOpts","previewEl: HTMLElement | null"],"sources":["../src/directives/phone.ts"],"sourcesContent":["import {\n  DEFAULT_BLOCKLIST,\n  DEFAULT_REGION_FALLBACKS,\n} from '../utils/phone/constants'\nimport { normalisePhone } from '../utils/phone/normalisePhone'\nimport type { PhoneNormOptions } from '../utils/phone/types'\n\n/**\n * Public options accepted by the v-phone directive binding.\n *\n * Usage:\n * <input v-phone=\"{ autoFormat: true, previewSelector: '#phonePreview' }\" />\n * <input v-phone=\"{ onnormalised: (result) => console.log(result) }\" />\n */\nexport type PhoneOpts = PhoneNormOptions & {\n  autoFormat?: boolean\n  autoFormatEvents?: {\n    onInput?: boolean\n    onBlur?: boolean\n  }\n  previewSelector?: string\n  onnormalised?: (r: ReturnType<typeof normalisePhone>) => void\n}\n\n/**\n * Internal element shape so we can hang directive state on inputs.\n *\n * Must be an element that has a 'value' property (e.g., HTMLHTMLInputElement, HTMLTextAreaElement).\n *\n * @property {object} __phone__ - Directive state\n * @property {Function} __phone__.onEvent - Event handler for input/blur events\n * @property {HTMLElement | null} __phone__.previewEl - The resolved preview target element\n * @property {PhoneOpts} __phone__.opts - The resolved directive options\n */\ntype ElWithState = HTMLInputElement & {\n  __phone__?: {\n    onEvent: (e: Event) => void\n    previewEl?: HTMLElement | null\n    opts: PhoneOpts\n  }\n}\n\n/** Safely returns the global document when running in the browser. */\nfunction getDocument(): Document | null {\n  return typeof document === 'undefined' ? null : document\n}\n\n/**\n * Result returned when binding values are normalised.\n *\n * @property {PhoneOpts} opts - The resolved directive options\n * @property {HTMLElement | null} previewEl - The resolved preview target element\n */\ntype ResolvedOpts = {\n  opts: PhoneOpts\n  previewEl: HTMLElement | null\n  missingPreviewTarget: boolean\n}\n\n/**\n * Normalises directive binding values and resolves the preview target.\n *\n * @property {object} binding - The directive binding object\n * @property {PhoneOpts} binding.value - The directive binding value\n * @property {ElWithState} el - The host element for the directive\n * @returns {ResolvedOpts} The resolved options and preview element\n */\nfunction resolve(\n  binding: { value?: PhoneOpts },\n  el: ElWithState\n): ResolvedOpts {\n  const value = binding.value || {}\n  const doc = getDocument()\n\n  const opts: PhoneOpts = {\n    autoFormat: value.autoFormat ?? false,\n    previewSelector: value.previewSelector,\n    onnormalised: value.onnormalised,\n    blocklist: value.blocklist || DEFAULT_BLOCKLIST,\n    defaultCountry: value.defaultCountry,\n    fallbackCountries: value.fallbackCountries || [...DEFAULT_REGION_FALLBACKS],\n    allowedCountries: value.allowedCountries,\n    format: value.format,\n    stripExtensions: value.stripExtensions ?? true,\n    autoFormatEvents: {\n      onInput: value.autoFormatEvents?.onInput ?? true,\n      onBlur: value.autoFormatEvents?.onBlur ?? true,\n    },\n  }\n\n  const selector = value.previewSelector?.trim()\n  let previewEl: HTMLElement | null = null\n  let attemptedLookup = false\n\n  if (selector) {\n    const formRoot = el.closest('form')\n    if (formRoot) {\n      attemptedLookup = true\n      previewEl = formRoot.querySelector(selector) as HTMLElement | null\n    }\n\n    if (!previewEl && doc) {\n      attemptedLookup = true\n      previewEl = doc.querySelector(selector) as HTMLElement | null\n    }\n  }\n\n  return {\n    opts,\n    previewEl,\n    missingPreviewTarget: Boolean(selector && attemptedLookup && !previewEl && doc),\n  }\n}\n\n/**\n * Mirrors normalised values into the optional preview element.\n *\n * @property {HTMLElement | null | undefined} target - The element to update\n * @property {string | null} phone - The normalised phone number\n * @property {boolean} valid - Whether the phone number is valid\n * @returns {void}\n */\nfunction setPreview(\n  target: HTMLElement | null | undefined,\n  phone: string | null,\n  valid: boolean\n) {\n  if (!target) {\n    return\n  }\n\n  target.textContent = phone ?? ''\n  target.setAttribute('data-valid', String(valid))\n}\n\n/**\n * Vue directive hooks for v-phone.\n *\n * Usage:\n * <input v-phone=\"{ autoFormat: true, previewSelector: '#phonePreview' }\" />\n *\n * The directive emits a 'directive:phone:normalised' event on the host element.\n *\n * @property {HTMLInputElement} el - The host element for the directive\n * @property {object} binding - The directive binding object\n * @property {PhoneOpts} binding.value - The directive binding value\n */\nexport default {\n  /** Initialises listeners, preview target, and auto-format behaviour. */\n  mounted(el: HTMLInputElement, binding: { value?: PhoneOpts }) {\n    const input = el as ElWithState\n    const { opts, previewEl, missingPreviewTarget } = resolve(binding, input)\n\n    if (missingPreviewTarget) {\n      console.warn('[v-phone] Preview element not found for selector:', {\n        previewSelector: binding.value?.previewSelector,\n      })\n    }\n\n    const run = (raw: string) => {\n      const r = normalisePhone(raw, opts)\n\n      if (previewEl) {\n        setPreview(previewEl, r.phone, r.valid)\n      }\n\n      if (r.valid) {\n        return r\n      }\n\n      input.dispatchEvent(\n        new CustomEvent('directive:phone:normalised', { detail: r })\n      )\n      opts.onnormalised?.(r)\n\n      return r\n    }\n\n    const onEvent = (e: Event) => {\n      const raw = (e.target as HTMLInputElement).value\n      const r = run(raw)\n\n      if (opts.autoFormat && r.phone && raw !== r.phone) {\n        input.value = r.phone\n        input.dispatchEvent(new Event('input', { bubbles: true }))\n        input.dispatchEvent(new Event('change', { bubbles: true }))\n      }\n    }\n\n    run(input.value || '')\n\n    if (opts.autoFormatEvents?.onInput ?? true) {\n      input.addEventListener('input', onEvent)\n    }\n\n    if (opts.autoFormatEvents?.onBlur ?? true) {\n      input.addEventListener('blur', onEvent)\n    }\n\n    input.__phone__ = {\n      onEvent,\n      previewEl,\n      opts,\n    }\n  },\n\n  /**\n   * Re-resolves options whenever the binding object changes.\n   *\n   * @property {HTMLInputElement} el - The host element for the directive\n   * @property {object} binding - The directive binding object\n   * @property {PhoneOpts} binding.value - The directive binding value\n   * @returns {void}\n   */\n  updated(el: HTMLInputElement, binding: { value?: PhoneOpts }) {\n    const input = el as ElWithState\n\n    if (!input.__phone__) {\n      return\n    }\n\n    const { opts, previewEl, missingPreviewTarget } = resolve(binding, input)\n    input.__phone__.opts = opts\n\n    if (previewEl instanceof HTMLElement) {\n      input.__phone__.previewEl = previewEl\n    }\n\n    if (missingPreviewTarget) {\n      console.warn('[v-phone] Preview element not found for selector:', {\n        previewSelector: binding.value?.previewSelector,\n      })\n    }\n\n    const r = normalisePhone(input.value || '', opts)\n    setPreview(previewEl, r.phone, r.valid)\n  },\n\n  /**\n   * Tears down listeners/state when the host element leaves the DOM.\n   *\n   * @property {HTMLInputElement} el - The host element for the directive\n   * @returns {void}\n   */\n  beforeUnmount(el: HTMLInputElement) {\n    const input = el as ElWithState\n\n    if (!input.__phone__) {\n      return\n    }\n\n    input.removeEventListener('input', input.__phone__.onEvent)\n    input.removeEventListener('blur', input.__phone__.onEvent)\n\n    delete input.__phone__\n  },\n}\n"],"mappings":"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"}